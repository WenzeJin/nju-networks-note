---
description: TODO
---

# 网络层 第一部分 数据

## 功能与服务

交换/路由，转发，建立连接（虚电路），建立连接是可选的。

服务模型（QoS）：\
Best Effort (with no guarantees)

有的时候，并不是越复杂越好。

## 路由器与分组交换网络

Router Capacity = Number of ports X Speed of a port

<figure><img src=".gitbook/assets/截屏2024-06-15 17.06.12.png" alt="" width="563"><figcaption><p>一个路由器的内部结构</p></figcaption></figure>

如何确定转发到哪个接口？

**Longest prefix matching rule**

利用树状结构，将查询时间减小到实际意义上的O(1)&#x20;

Ouput Port 需要对包的传输进行分类、缓存、调度。

对不同类型的包，可以共享不同的带宽。

Port 采用 FIFO 策略：快，丢弃尾部无法入队的包。

优先级调度策略：根据不同的优先级分入不同的优先级队列 采用Round-robin可以使每个队列每轮传输一个数据报。FQ 与 WFQ 这些概念在后面的 QoS 章节还会提到，这里不用深究。

## 两种分组交换网络：虚电路与数据报网络

### **虚电路 Virtual Circut, VC**

网络服务针对包的流进行。面向连接的服务，比如ATM, x.25, Frame Relay

针对每个流，建立与取消连接，每个包携带 VC 鉴别id 而不是目的地址，路径上的每个路由器或者说交换机保存流状态，VC 需要提前预留相关的资源

保证了数据的有序和时延的可控，路径是单一的

### **数据报网络**

网络服务针对单个数据报进行，不需要建立连接，路由器或者说交换机不需要保存状态，数据报可能沿不同路径抵达目的地，数据抵达的顺序不做保证。

## IP 协议 the Internet Protocol

提供了无连接服务，是一种数据报网络，提供 Best Effort 服务，对服务质量 (Quality of Service) 没有任何保证，但是强调尽力而为。

拥有许多子协议，称为 IP 协议簇。例如 ARP 协议用于通过 IP 地址获得某个设备的物理地址，ICMP 协议用于传输一些控制信息等等。

### **IP 地址**

IPv4 地址： xxx.xxx.xxx.xxx 每一部分是一个8位二进制数，共4部分。

几种地址模式：\
个体或单播地址、广播地址、多播地址、任播地址

### IP 操作

**路由：**&#x4E3B;机和路由器维护路由表

**数据报生命周期：**&#x4E3A;了避免无限循环问题（回忆一下在链路层中是否有类似的问题？如何解决的？），引入生命周期的概念，使用 TTL 标识每个数据报的生命周期，如果 TTL = 0 则丢弃这个数据报而不转发。实际应用中一般用跳数影响 TTL。也就是每一个数据报经过的中间节点个数是有限的。

**切片与重组：**&#x4D;TU（Maximum Transmission Unit），Host 根据路径上的最小 MTU 进行切分，而 Router 根据下一跳 MTU 进行切分，直到满足要求。有关重组，只能在主机进行，因为路由器接收到的分片可能沿不同路径传输，无法重组。重组有可能失败因为某些切片在传输的过程当中丢失而失败。

**错误控制：**&#x49;P 不保证传输质量，如果发生丢弃包的操作，路由器应当尝试使用 ICMP 协议通知发送方。

**流控制：**&#x5728;缓冲区满时丢弃传入的数据报，并用 ICMP 协议相关内容通知发送方。

### IP 报文头

IPv4报文头中，主要有以下部分：

<figure><img src=".gitbook/assets/截屏2024-06-16 11.39.38.png" alt="" width="563"><figcaption><p>IPv4 报头的结构</p></figcaption></figure>

其中我们主要关注以下内容：Total Length 表示包长度，包括这个头；Fragment Offset 用于保存有关划分的一些信息，有的时候更高层（传输层）给我们的报文长度太长了，需要进行切分之后，才能在网络层中进行传输，如果要进行切分，则必须保存一些信息，我们才能在接受处重新整合；同时要说明的是校验和，将报文头中所有数据依次解释为 16 位无符号整数，并求和。求和过程中需要将校验和部分先设置成0，避免新的校验和结果和旧的校验和结果产生依赖关系。

### IP 地址与子网划分

**首先明确子网的数量，比如下图中共有六个子网：**

<figure><img src=".gitbook/assets/截屏2024-06-16 12.47.18.png" alt="" width="563"><figcaption><p>图中有多少个子网？</p></figcaption></figure>

暂时可以这样简单的理解：路由器就像“厚障壁”，被其隔开的，就形成一个个子网。

子网中较高位用于子网自身的地址，较低位用于子网内部的地址。较低位具体有多少位，就决定了这个子网可以有多少能用的地址。要注意的是，较低位有两个情况是不能用作内部地址的，一个是全0，这个预留为子网地址，一个是全1，这个预留为广播地址。

那么网络位究竟有多少位？可以按如下进行分类：同样要注意上述全0和全1的情况

<figure><img src=".gitbook/assets/截屏2024-06-16 12.49.51.png" alt="" width="563"><figcaption><p>五类IP地址</p></figcaption></figure>

A类，全0和全1（Network字段）均被保留，其中全1用于本地回环地址，支持 1.x.x.x - 126.x.x.x 其中每个网段支持  个主机，由于全0是网络地址，全1预留为广播地址

B类，128.0.x.x.x - 191.255.x.x，每个网段支持 个主机，同样预留了全0和全1

C类，192.0.0.x - 223.255.255.x，和上面一样预留两种。

这样的分类方式是否有点死板了？所以我们有一种方式可以自由确定哪些部分用于网络地址，哪些用于内部地址

### CIDR 表示

<figure><img src=".gitbook/assets/截屏2024-06-16 12.55.27.png" alt="" width="563"><figcaption><p>子网掩码与CIDR表示</p></figcaption></figure>

其中 Subnet 这一项，意思是子网掩码，描述了哪些位用于网络地址，为了简化表示，我们将子网掩码到底前多少位为1设为n，将地址表示为"A.B.C.D/n"的形式。作业和考试中如果要分配子网地址，也使用CIDR表示进行表达。

## IP 协议簇

### **NAT Network Address Translation**

**为什么没法用 IP 地址（IPv4）进行远程 MineCraft 联机？？？**

对于网络内流量和网络外流量，可以使用不同的地址，如果有数据需要穿过网络的边界，进行地址转换。

目的：隐藏网络内的IP地址，承担防火墙的作用；使一个机构可以拥有更多的IP地址；使自身的IP地址与外部变化隔离（比如运营商的变化）

**三种 NAT 方式：**

**静态 NAT：**&#x5185;网 IP 静态地绑定到一个预留的公网 IP 上，通常用于内网内的服务器

**动态 NAT：**&#x4E;AT 路由器维护一个 IP 池，如果有需求的话，将他们动态地绑定到内网的IP上，并且随着时间释放。

**单一地址：**&#x5BF9;外展示为一个地址，通过端口转换地址。将内网的一个（IP, port）映射到 (Single-IP, port)

NAT 技术是有争议的：

影响所有的 P2P 应用，因为客户端无法通过公网IP找到另一个客户端。Skype 采用了中继的方式来解决。（远程MC联机可以通过内网穿透的方式来解决）

### **ICMP**

封装在 IP 数据报当中，只不过令 type = 1，用于传输错误和控制信息。

了解 ping 的过程，traceroute 的过程。

ping 是一个常见的网络诊断工具，使用 ICMP 的 回显请求（Echo Request） 和 回显应答（Echo Reply） 消息来检测网络连接是否正常。具体工作原理如下：

• 发送 Echo Request: 当你运行 ping 命令时，计算机向目标主机发送 ICMP 回显请求消息（类型为 8，代码为 0）。这个消息包含发送方的 IP 地址、一个唯一的标识符和一些数据字段。

• 接收 Echo Reply: 如果目标主机能够接收到这个请求并且没有任何网络故障，它将返回一个 ICMP 回显应答消息（类型为 0，代码为 0），内容中会包括它接收到的请求的副本。

通过检查返回的应答包，ping 工具能够计算出从发送方到接收方的往返时间，并判断网络是否畅通。如果没有收到应答，则意味着目标主机不可达或存在网络问题。

traceroute 用于追踪从一个主机到另一个主机的数据包经过的路由路径。它通过发送带有 TTL（Time To Live） 值的 ICMP 数据包来工作。TTL 控制数据包的生命周期，当 TTL 值为 0 时，数据包会被丢弃，并返回一个 ICMP 超时（Time Exceeded） 消息。

具体步骤如下：

• 逐步增加 TTL 值: traceroute 会发送一系列的 ICMP 回显请求，每次递增 TTL 值。开始时，TTL 值为 1，发送到第一个路由器。第一个路由器收到数据包时将 TTL 减 1，TTL 为 0 时丢弃包，并返回一个 ICMP 超时消息（类型 11，代码 0）。

• 返回的超时消息: 返回的 ICMP 超时消息告诉 traceroute 该数据包在哪一跳被丢弃。traceroute 通过记录每个路由器的响应时间，逐步显示从源主机到目标主机的每一跳。

• 目标主机的回应: 当 TTL 值达到目标主机时，目标主机会返回一个 ICMP 回显应答消息（类型 0）。此时 traceroute 知道已经到达了目的地。

ICMP 在这两个工具中的作用是提供一种轻量级的机制来诊断网络连通性和路径信息。由于 ICMP 数据包很少被阻止，它们非常适合用于网络诊断。

### **DHCP and ARP**

我们在链路层中已经提到过了，虽然他们一定程度上是服务于链路层的，但是是在网络层中实现的

### **IPv6**

引入了流的概念\
去除了很多报文头中的内容，保留了 version 流量类型，将切片的信息保存为扩展报文头的形式，使用 next header，TTL 改为 Hop Limit 路由器根据流信息来决定如何路由与处理。可以理解为，IPv6通过打mod的方式为头添加选项和功能，如果用户的需求很简单，那么可以用一个简单的头来解决问题。

<figure><img src=".gitbook/assets/截屏2024-06-16 13.19.58.png" alt=""><figcaption><p>IPv6的头示意图</p></figcaption></figure>

路由器不再会切分报文，全部由主机完成，如果无法传输，直接放弃，并发送相应的控制信息。简化了处理逻辑

不再有广播地址，而是为广播预留了一个组播地址，因为广播具有很多弊端：唤醒所有节点，但是只有一小部分设备是相关的，并且可能引入广播风暴。

不再有 ARP，被 Neighbor Discovery 替代，利用ICMPv6和组播实现

#### IPv6 地址

单播、组播、任播

IPv4 地址可以转换为 IPv6地址：\
x:x:x:x:x:x:d.d.d.d, 2 possible ways\
0:0:0:0:0:0:13.1.68.3, simplified as ::13.1.68.3\
0:0:0:0:0:FFFF:129.144.52.38, simplified as ::FFFF:129.144.52.38

<figure><img src=".gitbook/assets/截屏2024-06-16 13.30.16.png" alt="" width="375"><figcaption><p>IPv4 》 6 的变化总结</p></figcaption></figure>

相对于v4的优点：

1. 地址数量大大增加，可扩展性增强
   1. 128bit
   2. 支持更多的组播地址
   3. 支持任播
   4. Address auto-configuration
2. 增强的可选机制
   1. 可以引入很多扩展报文头
   2. 扩展报文头基本不需要路由器介入处理，简化路由器的实现
   3. 移除了校验和，这一部分交给传输层
3. 支持资源分配
   1. 支持流量分类与流控制
   2. 支持了一些 QoS 保障，而不是纯粹的 best-effort
4. 在移动机制上更有效率和鲁棒性
5. 内建的安全机制，更强的 IP 层加密和认证

### 如何同时使用v4和v6

如何同时使用 IPv4与 v6，因为我们无法立即升级所有路由器： 利用同时支持二者的路由器，建立隧道，将IPv6报文封装在 IPv4中，从逻辑视角看，相当于在二者之间建立一条 IPv4 的隧道：

<figure><img src=".gitbook/assets/截屏2024-06-16 13.38.44.png" alt="" width="563"><figcaption><p>隧道方式实现兼容</p></figcaption></figure>

